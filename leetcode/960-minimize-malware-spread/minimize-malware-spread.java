class Solution {
      int[] par; 
     int[] rank; 
    public boolean union(int x , int y){ 
        int px = find(x); 
        int py = find(y); 
        if(px == py) return false; 
        if(rank[px] > rank[py]) { 
            par[py] = px; 
        } else if(rank[px] < rank[py]) { 
            par[px] = py; 
        } else { 
            par[px] = py; 
            rank[py]++; 
        } 
        return true; 
    } 
     
    public int find(int x){ 
        if(par[x] == x) return x; 
         
        int t = find(par[x]); 
        par[x] = t; 
        return t; 
    } 
    public int minMalwareSpread(int[][] graph, int[] initial) {
         int N = graph.length; 
        par = new int[N]; 
     rank = new int[N]; 
     for(int i = 0; i<N; i++){ 
         par[i] = i; 
         rank[i] = 1; 
     } 
        for(int i = 0; i<N; i++){ 
            for(int j = i+1; j<N; j++){ 
                if(graph[i][j] == 1){ 
                    union(i,j); 
                } 
            } 
        } 
        int[] size = new int[N]; 
        for(int i = 0; i<N; i++){ 
            size[find(i)]++; 
        } 
        int[]infcount = new int[N]; 
        for(int i = 0; i<initial.length; i++){ 
            int infnode = initial[i]; 
            int linfnode = find(infnode); 
            infcount[linfnode]++; 
        } 
         
        Arrays.sort(initial); 
         int ansidx = initial[0]; 
        int anscount = Integer.MIN_VALUE; 
          
         for(int i = 0; i<initial.length; i++){ 
            int infnode = initial[i]; 
            int linfnode = find(infnode); 
            if(infcount[linfnode]==1 && size[linfnode] > anscount){ 
                anscount = size[linfnode]; 
                ansidx = infnode; 
            } 
        } 
        return ansidx;     
    }
}